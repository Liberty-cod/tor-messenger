# Messenger.py
# Full single-file Messenger (Windows) with automatic Tor Expert Bundle download/start,
# hidden service creation, PyQt6 GUI, SOCKS (.onion) support and history saving.
#
# Usage:
#   python Messenger.py
#
# Notes:
#  - Designed for Windows. Adjust TOR_DIR / URLs for Linux/macOS manually if needed.
#  - The script may need a few minutes to download and unpack Tor.

import sys
import os
import subprocess
import time
import socket
import threading
import zipfile
import urllib.request
import shutil
import importlib
import traceback

# ------------------ Configuration ------------------
LISTEN_HOST = "127.0.0.1"
LISTEN_PORT = 5000
HISTORY_FILE = "history.txt"

# Where to put Tor on Windows
TOR_DIR = r"C:\Tor"
# NOTE: URL below may need updating in future. If download fails, replace with a valid Tor Expert Bundle URL.
TOR_DOWNLOAD_URL = "https://dist.torproject.org/torbrowser/13.0.13/tor-win32-0.4.8.13.zip"

# We'll look for tor.exe in candidate paths after extraction
TOR_EXE_CANDIDATES = [
    os.path.join(TOR_DIR, "tor.exe"),
    os.path.join(TOR_DIR, "Tor", "tor.exe"),
    os.path.join(os.environ.get("PROGRAMFILES", "C:\\Program Files"), "Tor", "tor.exe")
]

TORRC_PATH = os.path.join(TOR_DIR, "torrc")
HIDDEN_SERVICE_DIR = os.path.join(TOR_DIR, "hidden_service")
HOSTNAME_PATH = os.path.join(HIDDEN_SERVICE_DIR, "hostname")

POSSIBLE_SOCKS = [9150, 9050]  # Tor Browser usually 9150, Expert bundle 9050

# ------------------ Auto-install libs ------------------
def install_and_import(pkg_name, import_name=None):
    try:
        return importlib.import_module(import_name or pkg_name)
    except ImportError:
        print(f"[installer] Installing {pkg_name} ...")
        subprocess.check_call([sys.executable, "-m", "pip", "install", pkg_name])
        return importlib.import_module(import_name or pkg_name)

# ensure PyQt6 and pysocks
QtWidgets = install_and_import("PyQt6.QtWidgets")
QtCore = install_and_import("PyQt6.QtCore")
QtGui = install_and_import("PyQt6.QtGui")
socks = install_and_import("pysocks", "socks")

from PyQt6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout,
    QTextEdit, QLineEdit, QPushButton, QLabel, QMessageBox
)
from PyQt6.QtCore import QThread, pyqtSignal, QTimer

# ------------------ Tor helper functions ------------------
def find_existing_tor_exe():
    for p in TOR_EXE_CANDIDATES:
        if os.path.exists(p):
            return p
    return None

def download_tor_zip(dest_dir, url=TOR_DOWNLOAD_URL):
    os.makedirs(dest_dir, exist_ok=True)
    zip_path = os.path.join(dest_dir, "tor_download.zip")
    print("[tor] Downloading Tor bundle... (this can be large, please wait)")
    urllib.request.urlretrieve(url, zip_path)
    print("[tor] Download complete, extracting...")
    with zipfile.ZipFile(zip_path, "r") as zf:
        zf.extractall(dest_dir)
    os.remove(zip_path)
    print("[tor] Extracted to:", dest_dir)

def create_torrc():
    os.makedirs(HIDDEN_SERVICE_DIR, exist_ok=True)
    content = f"""# torrc generated by Messenger
HiddenServiceDir {HIDDEN_SERVICE_DIR}
HiddenServicePort {LISTEN_PORT} {LISTEN_HOST}:{LISTEN_PORT}
SocksPort 9050
"""
    with open(TORRC_PATH, "w", encoding="utf-8") as f:
        f.write(content)
    print("[tor] torrc created at", TORRC_PATH)

def start_tor(tor_exe_path):
    try:
        create_torrc()
        # Start tor with config - run in TOR_DIR to allow relative HiddenServiceDir (we used absolute anyway)
        print(f"[tor] Starting tor: {tor_exe_path}")
        proc = subprocess.Popen([tor_exe_path, "-f", TORRC_PATH],
                                cwd=TOR_DIR,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)
        # Wait for hostname (timeout 60s)
        timeout = 60
        for i in range(timeout):
            if os.path.exists(HOSTNAME_PATH):
                with open(HOSTNAME_PATH, "r", encoding="utf-8") as f:
                    onion = f.read().strip()
                print("[tor] Hidden service hostname found:", onion)
                return proc, onion
            time.sleep(1)
        print("[tor] Timeout waiting for hostname (hostname file not found)")
        return proc, None
    except Exception as e:
        print("[tor] start error:", e)
        traceback.print_exc()
        return None, None

def ensure_tor_and_start():
    # find existing tor.exe, else download & extract and then find
    tor_exe = find_existing_tor_exe()
    if tor_exe:
        print("[tor] Found existing tor executable:", tor_exe)
    else:
        # Download & extract
        try:
            download_tor_zip(TOR_DIR, TOR_DOWNLOAD_URL)
        except Exception as e:
            print("[tor] Download/extract failed:", e)
            return None, None, "download_failed"
        tor_exe = find_existing_tor_exe()
        if not tor_exe:
            # attempt to search in subdirs created by archive
            for root, dirs, files in os.walk(TOR_DIR):
                for name in files:
                    if name.lower() == "tor.exe":
                        tor_exe = os.path.join(root, name)
                        break
                if tor_exe:
                    break
    if not tor_exe:
        print("[tor] tor.exe not found after extraction.")
        return None, None, "not_found"
    proc, onion = start_tor(tor_exe)
    if proc is None:
        return None, None, "start_failed"
    return proc, onion, "ok"

def detect_socks_port():
    for port in POSSIBLE_SOCKS:
        try:
            s = socket.socket()
            s.settimeout(0.6)
            s.connect(("127.0.0.1", port))
            s.close()
            return port
        except:
            continue
    return None

# ------------------ Server thread ------------------
class ServerThread(QThread):
    new_message = pyqtSignal(str)
    log = pyqtSignal(str)

    def __init__(self, host, port):
        super().__init__()
        self.host = host
        self.port = port
        self._running = True
        self.server = None

    def run(self):
        try:
            self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.server.bind((self.host, self.port))
            self.server.listen(5)
            self.server.settimeout(1.0)
            self.log.emit(f"[server] Listening on {self.host}:{self.port}")
        except Exception as e:
            self.log.emit(f"[server] bind failed: {e}")
            return

        while self._running:
            try:
                conn, addr = self.server.accept()
            except socket.timeout:
                continue
            except Exception as e:
                self.log.emit(f"[server] accept error: {e}")
                continue
            try:
                data = b""
                conn.settimeout(1.0)
                while True:
                    chunk = conn.recv(65536)
                    if not chunk:
                        break
                    data += chunk
                if data:
                    try:
                        text = data.decode("utf-8", errors="ignore")
                    except:
                        text = "<binary>"
                    self.new_message.emit(text)
                    self.log.emit(f"[server] recv {len(data)} bytes from {addr[0]}:{addr[1]}")
            except Exception as e:
                self.log.emit(f"[server] recv error: {e}")
            finally:
                try:
                    conn.close()
                except:
                    pass

        try:
            self.server.close()
        except:
            pass
        self.log.emit("[server] stopped")

    def stop(self):
        self._running = False
        # make accept return
        try:
            socket.create_connection((self.host, self.port), timeout=0.5).close()
        except:
            pass

# ------------------ Send thread ------------------
class SendThread(QThread):
    log = pyqtSignal(str)

    def __init__(self, host, port, message, socks_port=None):
        super().__init__()
        self.host = host
        self.port = int(port)
        self.message = message
        self.socks_port = socks_port

    def run(self):
        try:
            if self.host.endswith(".onion"):
                if not self.socks_port:
                    self.log.emit("[send] SOCKS not available for .onion (9150/9050)")
                    return
                s = socks.socksocket()
                s.set_proxy(socks.SOCKS5, "127.0.0.1", self.socks_port)
            else:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(20)
            s.connect((self.host, self.port))
            s.sendall(self.message.encode("utf-8"))
            s.close()
            self.log.emit(f"[send] Sent to {self.host}:{self.port}")
        except Exception as e:
            self.log.emit(f"[send] Error: {e}")

# ------------------ GUI application ------------------
class MessengerGUI(QWidget):
    def __init__(self, onion_addr, tor_proc):
        super().__init__()
        self.setWindowTitle("Tor Messenger")
        self.resize(760, 640)
        self.tor_proc = tor_proc

        self.socks_port = detect_socks_port()
        self.onion_addr = onion_addr

        # layout
        v = QVBoxLayout(self)

        # status label
        self.status_label = QLabel()
        v.addWidget(self.status_label)

        # my address + copy + refresh
        h_my = QHBoxLayout()
        h_my.addWidget(QLabel("Мой адрес:"))
        self.my_line = QLineEdit()
        self.my_line.setReadOnly(True)
        h_my.addWidget(self.my_line)
        btn_copy = QPushButton("Копировать")
        btn_copy.clicked.connect(self.copy_my_addr)
        h_my.addWidget(btn_copy)
        btn_refresh = QPushButton("Обновить")
        btn_refresh.clicked.connect(self.refresh_all)
        h_my.addWidget(btn_refresh)
        v.addLayout(h_my)

        # peer address
        h_peer = QHBoxLayout()
        h_peer.addWidget(QLabel("Адрес собеседника:"))
        self.peer_line = QLineEdit()
        self.peer_line.setPlaceholderText("abc.onion:5000 или 1.2.3.4:5000")
        h_peer.addWidget(self.peer_line)
        v.addLayout(h_peer)

        # chat display
        self.chat = QTextEdit()
        self.chat.setReadOnly(True)
        v.addWidget(self.chat)

        # input + send
        h_send = QHBoxLayout()
        self.msg_input = QLineEdit()
        self.msg_input.setPlaceholderText("Введите сообщение...")
        h_send.addWidget(self.msg_input)
        btn_send = QPushButton("Отправить")
        btn_send.clicked.connect(self.on_send)
        h_send.addWidget(btn_send)
        v.addLayout(h_send)

        # internal
        self.server = ServerThread(LISTEN_HOST, LISTEN_PORT)
        self.server.new_message.connect(self.on_incoming)
        self.server.log.connect(self.log)
        self.server.start()

        self.load_history()
        self.refresh_all()

        # timer to update socks and onion status
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.periodic)
        self.timer.start(2500)  # every 2.5s

    # UI helpers
    def refresh_all(self):
        # update socks and my address
        self.socks_port = detect_socks_port()
        onion = None
        try:
            if os.path.exists(HOSTNAME_PATH):
                with open(HOSTNAME_PATH, "r", encoding="utf-8") as f:
                    onion = f.read().strip()
        except Exception as e:
            onion = None
        if onion:
            self.my_line.setText(f"{onion}:{LISTEN_PORT}")
        else:
            self.my_line.setText(f"{LISTEN_HOST}:{LISTEN_PORT}")
        status = f"SOCKS: {'127.0.0.1:%d' % self.socks_port if self.socks_port else 'NOT FOUND (9150/9050)'}"
        if onion:
            status += f"    |    Hidden service: {onion}:{LISTEN_PORT}"
        else:
            status += f"    |    Hidden service: (none yet)"
        self.status_label.setText(status)

    def copy_my_addr(self):
        QApplication.clipboard().setText(self.my_line.text())
        self.log(f"[system] Copied: {self.my_line.text()}")

    def log(self, text):
        self.chat.append(text)

    def on_incoming(self, text):
        line = f"[peer] {text}"
        self.chat.append(line)
        self.append_history(line)

    def on_send(self):
        text = self.msg_input.text().strip()
        dest = self.peer_line.text().strip()
        if not text or not dest:
            QMessageBox.information(self, "Ошибка", "Укажите адрес собеседника и сообщение.")
            return
        if ":" not in dest:
            QMessageBox.information(self, "Ошибка", "Адрес должен быть в формате host:port")
            return
        host, port_s = dest.rsplit(":", 1)
        try:
            port = int(port_s)
        except:
            QMessageBox.information(self, "Ошибка", "Порт должен быть числом")
            return
        out = f"[you -> {host}:{port}] {text}"
        self.chat.append(out)
        self.append_history(out)
        sender = SendThread(host, port, text, self.socks_port)
        sender.log.connect(self.log)
        sender.start()
        self.msg_input.clear()

    def append_history(self, line):
        try:
            with open(HISTORY_FILE, "a", encoding="utf-8") as f:
                f.write(line + "\n")
        except Exception as e:
            self.chat.append(f"[history error] {e}")

    def load_history(self):
        if os.path.exists(HISTORY_FILE):
            try:
                with open(HISTORY_FILE, "r", encoding="utf-8") as f:
                    for ln in f:
                        self.chat.append(ln.rstrip("\n"))
            except Exception as e:
                self.chat.append(f"[history load error] {e}")

    def periodic(self):
        # update socks and onion info in status label
        old = self.socks_port
        self.socks_port = detect_socks_port()
        if old != self.socks_port:
            self.log(f"[system] SOCKS port changed -> {self.socks_port}")
        self.refresh_all()

    def closeEvent(self, ev):
        try:
            self.server.stop()
            self.server.wait(1000)
        except:
            pass
        # attempt to terminate tor process if we started it
        try:
            if self.tor_proc:
                # best effort: terminate
                self.tor_proc.terminate()
        except:
            pass
        ev.accept()

# ------------------ Main ------------------
def main():
    # Ensure Tor: find or download & start
    tor_proc = None
    onion_addr = None
    tor_proc, onion_addr, status = None, None, None
    try:
        tor_proc, onion_addr, status = ensure_tor_and_start()
    except Exception as e:
        print("[main] ensure_tor_and_start failed:", e)

    if status != "ok":
        # if tor not available, offer to continue in local-only mode
        print("[main] Tor unavailable or failed to start; continuing in local-only mode.")
        # but still allow user to press on — the GUI will show fallback address

    app = QApplication(sys.argv)
    window = MessengerGUI(onion_addr, tor_proc)
    window.tor_proc = tor_proc
    window.show()
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
